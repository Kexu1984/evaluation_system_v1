在生成对应驱动的测试向量时必须遵循如下规则：
1. 生成的c语言驱动测试程序需要放在${device_name}/output/c_driver/test/目录下，文件命名为：<device>_test.c
2. <device>_test.c中的内容需要包含3个部分：接口测试，功能测试，边界测试
2.1）接口测试
- <device>_driver.h中列出的所有接口都需要在测试程序中被调用；
- 所有具有返回值的接口都需要在调用后对接口的返回值进行检查；
*******************************************************************
2.2）功能测试
- 需要测试设备所支持的完整功能，具体功能实现需要参考：${device_name}/input/目录下的文件描述
- 对于具有真实应用场景的功能，需要利用真实场景去进行结果对比，
例如：AES加密模块，在测试AES加密功能时，<device>_test.py还需要利用真实加解密库去同步计算，然后比较二者的结果去确认操作是否真实可靠；
- 测试必须包含Spec文档中描述的所有模式；
例如：DMA模块的测试除了包含mem2mem，还需要包含mem2peri, peri2mem，以及address fixed mode和address inc mode等所有场景
又例如：AES加密模块，测试加密时要测试到其支持的所有模式：ecb/cbc/cfb...
*******************************************************************
2.3）边界测试
- 测试必须包含边界条件测试；
例如：DMA模块搬运0字节数据的场景，AES模块加密输入数据为空的场景，AES加密模块目标地址为非法地址的场景等；
*******************************************************************

4. 测试程序中的main函数需要支持一个参数：address，这样生成的binary就可以支持动态的配置模块的寄存器地址区间了；

5. 每个测试binary的开始阶段需要封装一个test_init函数，内部必须调用一些公共的函数用于初始化与model的通信流程，相关接口说明如下：
5.1）int interface_layer_init(void)；test_init中必须要调用interface_layer_init接口用于初始化common环境；
*******************************************************************
5.2）int register_device(uint32_t device_id, uint32_t base_address, uint32_t size)；test_init中必须要调用register_device接口用于注册地址空间；
其中device_id表示设备id，当前可以用1表示；base_address就是步骤5中的address参数的值，size表示地址空间的大小，如果没有默认用0x1000表示
*******************************************************************

6. 对于需要测试中断的流程，注册的中断处理函数需要调用：int register_interrupt_handler(uint32_t interrupt_id, interrupt_handler_t handler)；
其中interrupt_id表示中断号，需要与模型中的中断号相匹配；handler表示中断处理函数，内部的实现逻辑按测试需求以及设备功能去实现；

7. 测试结束时，还需要额外的调用interface_layer_deinit()接口去卸载设备；
